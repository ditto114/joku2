<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>조쿠공대 관리페이지</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Pretendard', system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 120px 24px 40px;
            color: #1f2937;
            line-height: 1.5;
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 12px 24px 20px;
        }

        .header-row {
            background: rgba(255, 255, 255, 0.96);
            backdrop-filter: blur(12px);
            padding: 16px 24px;
            border-radius: 18px;
            margin: 0 auto;
            max-width: 1200px;
            box-shadow: 0 12px 30px rgba(17, 24, 39, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 26px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* 로그인 게이트 */
        #gate {
            max-width: 480px;
            margin: 140px auto 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 32px;
            border-radius: 24px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.25);
        }

        #gate h2 {
            font-size: 22px;
            margin-bottom: 20px;
            text-align: center;
        }

        #gate .row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        #gate input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 15px;
            transition: all 0.3s;
        }

        #gate input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        #gateMsg {
            text-align: center;
            color: #6b7280;
            font-size: 14px;
            margin-top: 8px;
        }

        /* 메인 컨텐츠 */
        main {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .view-card {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .home-card {
            align-items: center;
            text-align: center;
            gap: 18px;
        }

        .home-card h2 {
            font-size: 22px;
            font-weight: 700;
        }

        .home-card p {
            color: #4b5563;
            font-size: 15px;
        }

        .home-actions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-top: 4px;
        }

        .home-actions button {
            min-width: 220px;
            padding: 16px 28px;
            font-size: 16px;
        }

        .card h2 {
            font-size: 18px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .card-header h2 {
            margin-bottom: 0;
        }

        /* 예약 현황 */
        .reservation-card {
            padding: 28px;
        }

        .timer-card {
            padding: 24px;
        }

        .reservation-grid {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .turn-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 18px;
        }

        .turn-section {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid rgba(59, 130, 246, 0.25);
            padding: 18px 20px;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        /* Legacy slot styles kept for backwards compatibility with scripts that still call renderSlot */
        .slot-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slot {
            display: flex;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.75);
            padding: 10px 14px;
            border-radius: 12px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .slot-label {
            font-weight: 600;
            color: #1f2937;
        }

        .slot-value {
            font-weight: 600;
            color: #4338ca;
        }

        .slot-value.empty {
            color: #94a3b8;
            font-style: italic;
        }

        .turn-section.turn2 {
            background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
            border-color: rgba(168, 85, 247, 0.25);
        }

        .turn-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .turn-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
            font-size: 17px;
        }

        .turn-time {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #1d4ed8;
            background: white;
            padding: 6px 14px;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        }

        .turn2 .turn-time {
            color: #7c3aed;
        }

        .gear {
            width: 34px;
            height: 34px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .gear:hover {
            transform: rotate(30deg) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .gear svg {
            width: 18px;
            height: 18px;
            color: #6b7280;
        }

        .table-wrapper {
            overflow-x: auto;
        }

        .reservation-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 14px;
            overflow: hidden;
            font-size: 13px;
        }

        .reservation-table thead {
            background: rgba(59, 130, 246, 0.12);
        }

        .reservation-table th,
        .reservation-table td {
            padding: 10px 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            text-align: center;
            vertical-align: middle;
        }

        .reservation-table th[scope="row"] {
            background: rgba(148, 163, 184, 0.12);
            font-weight: 600;
            text-align: left;
            color: #1f2937;
            min-width: 88px;
        }

        .reservation-table td {
            min-width: 110px;
        }

        .cell-empty {
            color: #94a3b8;
            font-style: italic;
        }

        .cell-value {
            font-weight: 600;
            color: #1f2937;
        }

        .cell-sub {
            display: block;
            margin-top: 4px;
            font-size: 11px;
            color: #6366f1;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .cell-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .loot-mark {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            color: #2563eb;
        }

        .loot-mark input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #2563eb;
        }

        .loot-mark.is-disabled {
            opacity: 0.45;
        }

        .reservation-table button.copy-btn {
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 8px;
            border: 1px solid rgba(99, 102, 241, 0.4);
            background: rgba(99, 102, 241, 0.12);
            color: #3730a3;
        }

        .reservation-table button.copy-btn:hover:not([disabled]) {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-1px);
        }

        .reservation-table button.copy-btn.copied {
            background: rgba(34, 197, 94, 0.18);
            border-color: rgba(34, 197, 94, 0.45);
            color: #166534;
        }

        .reservation-table button.copy-btn[disabled] {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .reservation-table .deposit {
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            color: #065f46;
        }

        .timer-actions {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 18px;
            gap: 10px;
        }

        .timer-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
        }

        .timer-item {
            background: linear-gradient(135deg, #f5f3ff 0%, #ede9fe 100%);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 16px;
            padding: 16px 18px;
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.12);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .timer-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timer-name {
            width: 100%;
            font-size: 15px;
            font-weight: 600;
            padding: 8px 12px;
            border-radius: 12px;
            border: 2px solid rgba(129, 140, 248, 0.25);
            background: rgba(255, 255, 255, 0.92);
            transition: all 0.2s ease;
        }

        .timer-name:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .timer-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .timer-controls .btn-primary,
        .timer-controls .btn-secondary,
        .timer-controls .btn-danger,
        .timer-controls .btn-repeat {
            flex: 1;
            min-width: 0;
            justify-content: center;
            padding: 8px 10px;
            font-size: 13px;
        }

        .btn-repeat {
            border: 1px solid rgba(99, 102, 241, 0.35);
            background: rgba(255, 255, 255, 0.9);
            color: #4c1d95;
        }

        .btn-repeat.is-active {
            background: rgba(129, 140, 248, 0.18);
            border-color: rgba(99, 102, 241, 0.6);
            color: #312e81;
        }

        .timer-config {
            display: flex;
            align-items: center;
            gap: 14px;
            flex-wrap: wrap;
        }

        .timer-input {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            color: #4338ca;
        }

        .timer-input input {
            width: 68px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 2px solid rgba(129, 140, 248, 0.3);
            background: white;
            text-align: center;
            font-size: 14px;
            font-variant-numeric: tabular-nums;
            transition: all 0.2s ease;
        }

        .timer-input input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
        }

        .timer-remaining {
            font-family: 'Courier New', monospace;
            font-size: 26px;
            font-weight: 700;
            color: #1d4ed8;
            text-align: center;
        }

        .timer-state {
            align-self: flex-start;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(148, 163, 184, 0.18);
            color: #374151;
        }

        .timer-state.is-running {
            background: rgba(74, 222, 128, 0.25);
            color: #166534;
        }

        .timer-state.is-finished {
            background: rgba(248, 113, 113, 0.25);
            color: #b91c1c;
        }

        .timer-empty {
            padding: 22px;
            border-radius: 16px;
            border: 2px dashed rgba(148, 163, 184, 0.35);
            color: #6b7280;
            background: rgba(255, 255, 255, 0.75);
            font-weight: 500;
            text-align: center;
        }

        .extra-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }

        .extra-card {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-radius: 16px;
            padding: 14px 16px;
            border: 1px solid rgba(245, 158, 11, 0.25);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .extra-card.skill2 {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            border-color: rgba(124, 58, 237, 0.25);
        }

        .extra-card.enre {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border-color: rgba(34, 197, 94, 0.25);
        }

        .extra-title {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #92400e;
        }

        .extra-card.skill2 .extra-title {
            color: #5b21b6;
        }

        .extra-card.enre .extra-title {
            color: #166534;
        }

        .extra-content {
            color: #78350f;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.75);
            border-radius: 10px;
            font-weight: 600;
        }

        .extra-card.skill2 .extra-content {
            color: #4c1d95;
        }

        .extra-card.enre .extra-content {
            color: #166534;
        }

        .extra-content.empty {
            color: #94a3b8;
            font-style: italic;
            font-weight: 500;
        }

        .extra-card.skill2 .extra-content.empty,
        .extra-card.enre .extra-content.empty {
            color: #94a3b8;
        }

        /* 입력 폼 */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .input-wrapper {
            position: relative;
        }

        .input-wrapper input {
            width: 100%;
            padding: 12px 16px;
            padding-right: 60px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 15px;
            transition: all 0.3s;
        }

        .input-wrapper input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .input-suffix {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            font-size: 13px;
            font-weight: 600;
        }

        /* 버튼 */
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn-ghost {
            background: rgba(255, 255, 255, 0.4);
            color: #374151;
        }

        .btn-ghost:hover {
            background: rgba(255, 255, 255, 0.6);
        }

        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-full {
            width: 100%;
        }

        /* 초기화 섹션 */
        .reset-select {
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .reset-select option {
            padding: 8px;
            border-radius: 6px;
            margin: 2px 0;
        }

        .reset-select option:checked {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* 공대원 섹션 */
        .member-list {
            display: grid;
            gap: 8px;
            max-height: 360px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .member-list::-webkit-scrollbar {
            width: 6px;
        }

        .member-list::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.7);
            border-radius: 999px;
        }

        .member-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            border-radius: 12px;
            transition: all 0.2s;
        }

        .member-item:hover {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            transform: translateX(4px);
        }

        .member-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .member-name {
            font-weight: 600;
            color: #111827;
        }

        .member-job {
            color: #6b7280;
            font-size: 14px;
            padding: 4px 12px;
            background: white;
            border-radius: 8px;
        }

        /* 상태 메시지 */
        .status-msg {
            font-size: 13px;
            color: #6b7280;
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 10px;
            background: #f9fafb;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-msg.success {
            background: #dcfce7;
            color: #166534;
        }

        .status-msg.error {
            background: #fee2e2;
            color: #991b1b;
        }

        /* 모달 */
        dialog {
            border: none;
            border-radius: 20px;
            padding: 0;
            max-width: 92vw;
            width: 460px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        dialog.modal-wide {
            width: 520px;
        }

        dialog.modal-large {
            width: 640px;
        }

        dialog::backdrop {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }

        .modal {
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h3 {
            font-size: 20px;
            font-weight: 600;
        }

        .modal-body {
            display: grid;
            gap: 16px;
        }

        .modal-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-subactions {
            justify-content: flex-start;
        }

        .hidden {
            display: none !important;
        }

        /* 로딩 애니메이션 */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

    </style>
</head>

<body>
    <header>
        <div class="header-row">
            <h1>🎮 조쿠공대 관리페이지</h1>
            <div class="header-actions">
                <button class="btn-secondary" data-open-modal="pricesDialog">💰 시세 변경</button>
                <button class="btn-secondary" data-open-modal="resetDialog">🗑️ 초기화</button>
                <button class="btn-secondary" data-open-modal="membersDialog">🛡️ 공대원 관리</button>
                <button id="sendScreenshot" class="btn-ghost">🖼️ 화면 전송</button>
            </div>
        </div>
    </header>

    <!-- 로그인 게이트 -->
    <section id="gate" class="hidden">
        <h2>🔐 관리자 로그인</h2>
        <div class="row">
            <input id="pwd" type="password" placeholder="관리자 비밀번호를 입력하세요" />
            <button id="loginBtn" class="btn-primary">접속</button>
        </div>
        <div id="gateMsg"></div>
    </section>

    <!-- 메인 컨텐츠 -->
    <main id="app" class="hidden">
        <section class="card home-card view-card" id="homeCard">
            <h2>📋 사용할 도구를 선택하세요</h2>
            <p>관리 페이지에서 자쿰 예약 현황과 혼테일 타이머를 빠르게 관리할 수 있습니다.</p>
            <div class="home-actions">
                <button class="btn-primary" data-nav-target="reservation">자쿰 예약 현황 바로가기</button>
                <button class="btn-secondary" data-nav-target="timer">혼테일 타이머 바로가기</button>
            </div>
        </section>

        <section class="card reservation-card view-card hidden" id="reservationStatusCard">
            <div class="card-header">
                <h2>🧑‍🤝‍🧑 현재 예약 현황</h2>
                <div class="card-header-actions view-nav">
                    <button class="btn-ghost" data-nav-target="home">← 도구 선택</button>
                    <button class="btn-secondary" data-nav-target="timer">혼테일 타이머</button>
                </div>
            </div>
            <div id="statusBox" class="reservation-grid">
                <div class="status-msg">불러오는 중...</div>
            </div>
        </section>

        <section class="card timer-card view-card hidden" id="timerView">
            <div class="card-header">
                <h2>🐉 혼테일 타이머</h2>
                <div class="card-header-actions view-nav">
                    <button class="btn-ghost" data-nav-target="home">← 도구 선택</button>
                    <button class="btn-secondary" data-nav-target="reservation">자쿰 예약 현황</button>
                </div>
            </div>
            <div class="timer-actions">
                <button id="addTimer" class="btn-primary">➕ 타이머 추가</button>
            </div>
            <div id="timerList" class="timer-list">
                <div class="timer-empty">타이머를 추가하면 이곳에 표시됩니다.</div>
            </div>
        </section>
    </main>

    <!-- 시세 변경 모달 -->
    <dialog id="pricesDialog">
        <div class="modal">
            <h3>💰 시세 변경</h3>
            <div class="modal-body">
                <div class="form-group">
                    <label>확투 (1순, 2순)</label>
                    <div class="input-wrapper">
                        <input id="p1" type="number" placeholder="1000" />
                        <span class="input-suffix">골드</span>
                    </div>
                </div>
                <div class="form-group">
                    <label>3순</label>
                    <div class="input-wrapper">
                        <input id="p2" type="number" placeholder="800" />
                        <span class="input-suffix">골드</span>
                    </div>
                </div>
                <div class="form-group">
                    <label>스킬북1</label>
                    <div class="input-wrapper">
                        <input id="p3" type="number" placeholder="1000" />
                        <span class="input-suffix">골드</span>
                    </div>
                </div>
                <div class="form-group">
                    <label>스킬북2</label>
                    <div class="input-wrapper">
                        <input id="p4" type="number" placeholder="300" />
                        <span class="input-suffix">골드</span>
                    </div>
                </div>
            </div>
            <div id="priceMsg" class="status-msg hidden"></div>
            <div class="modal-actions">
                <button class="btn-secondary" data-close-modal>닫기</button>
                <button id="savePrices" class="btn-primary">💾 시세 저장</button>
            </div>
        </div>
    </dialog>

    <!-- 초기화 모달 -->
    <dialog id="resetDialog" class="modal-wide">
        <div class="modal">
            <h3>🗑️ 예약 초기화</h3>
            <div class="modal-body">
                <select id="resetSel" class="reset-select" multiple>
                    <option value="turn1_first">1트 1순</option>
                    <option value="turn1_second">1트 2순</option>
                    <option value="turn1_third">1트 3순</option>
                    <option value="turn2_first">2트 1순</option>
                    <option value="turn2_second">2트 2순</option>
                    <option value="turn2_third">2트 3순</option>
                    <option value="skillbook1">스킬북1</option>
                    <option value="skillbook2">스킬북2</option>
                    <option value="enre_eat">엔레먹자</option>
                </select>
                <div class="btn-group">
                    <button id="resetSome" class="btn-primary" style="flex: 1;">선택 초기화</button>
                    <button id="resetAll" class="btn-danger" style="flex: 1;">모두 초기화</button>
                </div>
            </div>
            <div id="resetMsg" class="status-msg hidden"></div>
            <div class="modal-actions">
                <button class="btn-secondary" data-close-modal>닫기</button>
            </div>
        </div>
    </dialog>

    <!-- 공대원 관리 모달 -->
    <dialog id="membersDialog" class="modal-large">
        <div class="modal">
            <h3>🛡️ 공대원 명단 관리</h3>
            <div class="modal-subactions btn-group">
                <button id="mAdd" class="btn-primary">➕ 공대원 추가</button>
                <button id="mDel" class="btn-danger">➖ 공대원 제거</button>
                <button id="mReload" class="btn-secondary">🔄 새로고침</button>
            </div>
            <div id="mBox" class="member-list">
                <div class="status-msg">불러오는 중...</div>
            </div>
            <div id="mMsg" class="status-msg hidden"></div>
            <div class="modal-actions">
                <button class="btn-secondary" data-close-modal>닫기</button>
            </div>
        </div>
    </dialog>

    <!-- 출발시간 변경 모달 -->
    <dialog id="timeDialog">
        <div class="modal">
            <h3 id="timeTitle">⏰ 출발시간 변경</h3>
            <div class="modal-grid">
                <div class="form-group">
                    <label>시 (0-23)</label>
                    <input id="th" type="number" min="0" max="23" />
                </div>
                <div class="form-group">
                    <label>분 (0-59)</label>
                    <input id="tm" type="number" min="0" max="59" />
                </div>
            </div>
            <div class="modal-actions">
                <button id="timeCancel" class="btn-secondary">취소</button>
                <button id="timeSave" class="btn-primary">저장</button>
            </div>
        </div>
    </dialog>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const $ = (id) => document.getElementById(id);
        const app = $('app'), gate = $('gate'), gateMsg = $('gateMsg');
        const headerActions = document.querySelector('.header-actions');
        const viewSections = {
            home: $('homeCard'),
            reservation: $('reservationStatusCard'),
            timer: $('timerView')
        };
        const timerList = $('timerList');
        const addTimerBtn = $('addTimer');
        const PWD_KEY = 'admin_password';
        const getPwd = () => sessionStorage.getItem(PWD_KEY) || '';
        const setPwd = v => sessionStorage.setItem(PWD_KEY, v || '');
        const clearPwd = () => sessionStorage.removeItem(PWD_KEY);
        const authHeaders = () => ({ 'x-admin-password': getPwd() });

        const LOOT_STORAGE_KEY = 'joku_admin_loot_state_v1';

        let activeView = 'home';
        let statusViewInitialized = false;
        let timerData = [];
        let timerIndex = new Map();
        let timerTickHandle = null;
        let lastTimerTickAt = null;
        let timersLoadedOnce = false;

        function withStorage(fn, fallback) {
            try { return fn(); }
            catch { return fallback; }
        }

        let lootState = withStorage(() => JSON.parse(localStorage.getItem(LOOT_STORAGE_KEY) || '{}'), {});

        function saveLootState() {
            withStorage(() => localStorage.setItem(LOOT_STORAGE_KEY, JSON.stringify(lootState)), null);
        }

        const escapeHtml = (str = '') => String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

        const escapeAttr = (str = '') => escapeHtml(str).replace(/`/g, '&#96;');

        const clampTimerValue = (ms) => {
            if (!Number.isFinite(ms)) return 0;
            return Math.max(0, Math.round(ms));
        };

        const clampTimerInput = (value, max) => {
            const num = Number(value);
            if (!Number.isFinite(num)) return 0;
            return Math.max(0, Math.min(max, Math.floor(num)));
        };

        const formatTimerDuration = (ms) => {
            const totalSeconds = Math.max(0, Math.floor(clampTimerValue(ms) / 1000));
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        function ensureTimerTicker() {
            if (timerTickHandle) return;
            lastTimerTickAt = Date.now();
            timerTickHandle = setInterval(() => updateTimerCountdowns(), 1000);
        }

        function stopTimerTicker() {
            if (timerTickHandle) {
                clearInterval(timerTickHandle);
                timerTickHandle = null;
            }
            lastTimerTickAt = null;
        }

        function activateView(view = 'home') {
            const target = viewSections[view] ? view : 'home';
            activeView = target;
            Object.entries(viewSections).forEach(([key, el]) => {
                if (!el) return;
                if (key === target) {
                    el.classList.remove('hidden');
                } else {
                    el.classList.add('hidden');
                }
            });

            if (headerActions) {
                if (target === 'reservation') {
                    headerActions.classList.remove('hidden');
                } else {
                    headerActions.classList.add('hidden');
                }
            }

            if (target !== 'timer') {
                stopTimerTicker();
            }

            if (target === 'reservation' && !statusViewInitialized) {
                statusViewInitialized = true;
                loadStatus();
            }

            if (target === 'timer') {
                if (!timersLoadedOnce) {
                    loadTimers(true);
                } else {
                    loadTimers();
                }
                ensureTimerTicker();
            }
        }

        function setTimerSnapshot(snapshot) {
            if (!snapshot || typeof snapshot !== 'object') return;
            const timers = Array.isArray(snapshot.timers) ? snapshot.timers : [];

            const sanitizedTimers = timers
                .filter(item => item && typeof item === 'object')
                .map(item => {
                    const id = String(item.id ?? '').trim();
                    if (!id) return null;
                    const durationMs = clampTimerValue(item.durationMs);
                    const remainingMs = clampTimerValue(item.remainingMs);
                    return {
                        id,
                        name: String(item.name ?? ''),
                        durationMs,
                        remainingMs,
                        isRunning: Boolean(item.isRunning) && remainingMs > 0,
                        repeat: Boolean(item.repeat)
                    };
                })
                .filter(Boolean);

            timerData = sanitizedTimers.map(timer => ({ ...timer }));
            timerIndex = new Map(timerData.map(timer => [timer.id, timer]));
            renderTimerList();
            updateTimerCountdowns(true);
            timersLoadedOnce = true;

            if (activeView === 'timer') {
                ensureTimerTicker();
            } else {
                stopTimerTicker();
            }
        }

        function renderTimerList() {
            if (!timerList) return;
            if (!timerData || timerData.length === 0) {
                timerList.innerHTML = '<div class="timer-empty">타이머를 추가하면 이곳에 표시됩니다.</div>';
                return;
            }

            timerList.innerHTML = timerData.map(renderTimerItem).join('');
        }

        function renderTimerItem(timer) {
            const minutes = Math.floor(timer.durationMs / 60000);
            const seconds = Math.floor((timer.durationMs / 1000) % 60);
            const state = timer.isRunning && timer.remainingMs > 0
                ? 'running'
                : (timer.remainingMs <= 0 ? 'finished' : 'paused');
            const stateLabel = state === 'running' ? '진행 중' : (state === 'finished' ? '종료' : '대기');
            const remainingDisplay = formatTimerDuration(timer.remainingMs);
            const toggleLabel = timer.isRunning ? '리셋' : '시작';
            const repeatClass = timer.repeat ? 'btn-repeat is-active' : 'btn-repeat';

            return `
                <div class="timer-item" data-timer-id="${escapeAttr(timer.id)}">
                    <div class="timer-row">
                        <input type="text" class="timer-name" value="${escapeHtml(timer.name || '')}" placeholder="타이머 이름" />
                        <div class="timer-controls">
                            <button type="button" class="btn-primary" data-timer-action="toggle">${toggleLabel}</button>
                            <button type="button" class="${repeatClass}" data-timer-action="repeat">반복</button>
                            <button type="button" class="btn-danger" data-timer-action="delete">삭제</button>
                        </div>
                    </div>
                    <div class="timer-row">
                        <div class="timer-config">
                            <label class="timer-input">
                                <input type="number" inputmode="numeric" class="timer-minute" min="0" max="720" value="${minutes}" />
                                <span>분</span>
                            </label>
                            <label class="timer-input">
                                <input type="number" inputmode="numeric" class="timer-second" min="0" max="59" value="${seconds}" />
                                <span>초</span>
                            </label>
                            <span class="timer-state${state === 'running' ? ' is-running' : state === 'finished' ? ' is-finished' : ''}" data-role="state" data-state="${state}">${stateLabel}</span>
                        </div>
                        <div class="timer-remaining" data-role="remaining">${remainingDisplay}</div>
                    </div>
                </div>`;
        }

        function updateTimerCountdowns(force = false) {
            if (!timerList || timerIndex.size === 0) return;
            const now = Date.now();
            if (force || lastTimerTickAt == null) {
                lastTimerTickAt = now;
            }

            const delta = force || lastTimerTickAt == null ? 0 : Math.max(0, now - lastTimerTickAt);
            lastTimerTickAt = now;

            timerIndex.forEach(timer => {
                if (!timer) return;
                timer.remainingMs = clampTimerValue(timer.remainingMs);

                if (timer.isRunning && delta > 0) {
                    const duration = clampTimerValue(timer.durationMs);
                    const baseRemaining = clampTimerValue(timer.remainingMs);
                    let nextRemaining = baseRemaining - delta;

                    if (nextRemaining <= 0) {
                        if (timer.repeat && duration > 0) {
                            const overshoot = Math.abs(nextRemaining);
                            const remainder = overshoot % duration;
                            nextRemaining = duration - remainder;
                            if (remainder === 0) {
                                nextRemaining = duration;
                            }
                            timer.remainingMs = nextRemaining;
                            timer.isRunning = true;
                        } else {
                            timer.remainingMs = 0;
                            timer.isRunning = false;
                        }
                    } else {
                        timer.remainingMs = nextRemaining;
                    }
                }

                if (!timer.isRunning && timer.remainingMs < 0) {
                    timer.remainingMs = 0;
                }
            });

            timerList.querySelectorAll('.timer-item').forEach(item => {
                const id = item.getAttribute('data-timer-id');
                if (!id) return;
                const timer = timerIndex.get(id);
                if (!timer) return;

                const remaining = clampTimerValue(timer.remainingMs);
                const state = timer.isRunning ? 'running' : (remaining <= 0 ? 'finished' : 'paused');

                const remainingEl = item.querySelector('[data-role="remaining"]');
                if (remainingEl) {
                    remainingEl.textContent = formatTimerDuration(remaining);
                }

                const stateEl = item.querySelector('[data-role="state"]');
                if (stateEl) {
                    const label = state === 'running' ? '진행 중' : (state === 'finished' ? '종료' : '대기');
                    stateEl.textContent = label;
                    stateEl.dataset.state = state;
                    stateEl.classList.toggle('is-running', state === 'running');
                    stateEl.classList.toggle('is-finished', state === 'finished');
                }

                const toggleBtn = item.querySelector('button[data-timer-action="toggle"]');
                if (toggleBtn) {
                    toggleBtn.textContent = timer.isRunning ? '리셋' : '시작';
                }

                const repeatBtn = item.querySelector('button[data-timer-action="repeat"]');
                if (repeatBtn) {
                    repeatBtn.classList.toggle('is-active', Boolean(timer.repeat));
                }
            });
        }

        async function loadTimers(showFeedback = false) {
            if (!getPwd()) return;
            try {
                const r = await fetch('/api/timers', {
                    headers: authHeaders(),
                    credentials: 'same-origin'
                });
                const j = await jsonOrThrow(r);
                if (!j?.ok) {
                    throw new Error(j?.error || '타이머 정보를 불러오지 못했습니다.');
                }
                const snapshot = j.snapshot || { serverTime: j.serverTime, timers: j.timers };
                setTimerSnapshot(snapshot);
            } catch (e) {
                console.error(e);
            }
        }

        async function requestTimer(path, options) {
            try {
                const r = await fetch(path, options);
                const j = await jsonOrThrow(r);
                if (!j?.ok) {
                    throw new Error(j?.error || '요청이 실패했습니다.');
                }
                await loadTimers();
                return j;
            } catch (e) {
                console.error(e);
                throw e;
            }
        }

        if (addTimerBtn) {
            addTimerBtn.addEventListener('click', async () => {
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                addTimerBtn.disabled = true;
                try {
                    await requestTimer('/api/timers', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...authHeaders() },
                        credentials: 'same-origin',
                        body: JSON.stringify({})
                    });
                } catch (e) {
                    // 에러는 콘솔에 기록됨
                } finally {
                    addTimerBtn.disabled = false;
                }
            });
        }

        if (timerList) {
            timerList.addEventListener('click', async (event) => {
                const btn = event.target.closest('button[data-timer-action]');
                if (!btn) return;
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                const row = btn.closest('.timer-item');
                if (!row) return;
                const id = row.getAttribute('data-timer-id');
                if (!id) return;
                const action = btn.getAttribute('data-timer-action');
                if (action === 'delete' && !confirm('선택한 타이머를 삭제하시겠습니까?')) {
                    return;
                }

                btn.disabled = true;
                try {
                    if (action === 'toggle') {
                        const current = timerIndex.get(id);
                        const running = current?.isRunning;
                        const endpoint = running ? 'reset' : 'start';
                        await requestTimer(`/api/timers/${id}/${endpoint}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', ...authHeaders() },
                            credentials: 'same-origin',
                            body: JSON.stringify({})
                        });
                    } else if (action === 'repeat') {
                        const current = timerIndex.get(id);
                        const nextRepeat = !Boolean(current?.repeat);
                        await requestTimer(`/api/timers/${id}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json', ...authHeaders() },
                            credentials: 'same-origin',
                            body: JSON.stringify({ repeat: nextRepeat })
                        });
                    } else if (action === 'delete') {
                        await requestTimer(`/api/timers/${id}`, {
                            method: 'DELETE',
                            headers: { ...authHeaders() },
                            credentials: 'same-origin'
                        });
                    }
                } catch (e) {
                    // 에러는 콘솔에 기록됨
                } finally {
                    btn.disabled = false;
                }
            });

            timerList.addEventListener('change', async (event) => {
                const input = event.target;
                if (!input.classList.contains('timer-minute') && !input.classList.contains('timer-second')) return;
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                const row = input.closest('.timer-item');
                if (!row) return;
                const id = row.getAttribute('data-timer-id');
                if (!id) return;
                const minuteInput = row.querySelector('.timer-minute');
                const secondInput = row.querySelector('.timer-second');
                const minutes = clampTimerInput(minuteInput?.value, 720);
                const seconds = clampTimerInput(secondInput?.value, 59);
                const current = timerIndex.get(id);
                if (current) {
                    const currentMinutes = Math.floor(current.durationMs / 60000);
                    const currentSeconds = Math.floor((current.durationMs / 1000) % 60);
                    if (minutes === currentMinutes && seconds === currentSeconds) {
                        if (minuteInput) minuteInput.value = currentMinutes;
                        if (secondInput) secondInput.value = currentSeconds;
                        return;
                    }
                }

                input.disabled = true;
                try {
                    await requestTimer(`/api/timers/${id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json', ...authHeaders() },
                        credentials: 'same-origin',
                        body: JSON.stringify({ minutes, seconds })
                    });
                } catch (e) {
                    const fallback = timerIndex.get(id);
                    if (fallback) {
                        if (minuteInput) minuteInput.value = Math.floor(fallback.durationMs / 60000);
                        if (secondInput) secondInput.value = Math.floor((fallback.durationMs / 1000) % 60);
                    }
                } finally {
                    input.disabled = false;
                }
            });

            timerList.addEventListener('focusout', async (event) => {
                const input = event.target;
                if (!input.classList.contains('timer-name')) return;
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                const row = input.closest('.timer-item');
                if (!row) return;
                const id = row.getAttribute('data-timer-id');
                if (!id) return;
                const nextName = input.value?.trim() ?? '';
                const current = timerIndex.get(id);
                if (current && nextName === current.name) {
                    input.value = current.name;
                    return;
                }

                input.readOnly = true;
                try {
                    await requestTimer(`/api/timers/${id}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json', ...authHeaders() },
                        credentials: 'same-origin',
                        body: JSON.stringify({ name: nextName })
                    });
                } catch (e) {
                    const fallback = timerIndex.get(id);
                    input.value = fallback ? fallback.name : '새 타이머';
                } finally {
                    input.readOnly = false;
                }
            });
        }

        const formatDepositValue = (detail = {}) => {
            if (!detail.hasReservation) return '<span class="cell-empty">-</span>';
            const value = detail.deposit ?? detail.rawDeposit;
            if (value == null || value === '') return '<span class="cell-empty">-</span>';
            const num = Number(value);
            if (Number.isNaN(num)) {
                return `<span class="deposit">${escapeHtml(value)}</span>`;
            }
            return `<span class="deposit">${num.toLocaleString('ko-KR')}</span>`;
        };
        // ── "현재 예약 현황" 카드 요소 찾기 ───────────────────────────────
        function findReservationCard() {
            const byId = document.getElementById('reservationStatusCard');
            if (byId) return byId;
            const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4'));
            const h = headings.find(el => el.textContent.trim().includes('현재 예약 현황'));
            if (!h) return null;
            const candidates = [h.closest('.card'), h.closest('section'), h.closest('article'), h.parentElement].filter(Boolean);
            return candidates[0] || null;
        }

        // ── 브라우저 화면 공유 기반 캡쳐(선택된 표면에서 대상 요소 영역만 크롭) ──
        async function captureCardViaScreenShare(targetEl) {
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: { displaySurface: 'browser' },
                audio: false
            });
            try {
                const video = document.createElement('video');
                video.srcObject = stream;
                video.muted = true;
                video.playsInline = true;
                await video.play();
                await new Promise(r => { if (video.readyState >= 2) r(); else video.onloadeddata = () => r(); });

                const rect = targetEl.getBoundingClientRect();
                const cssW = window.innerWidth;
                const cssH = window.innerHeight;
                const vidW = video.videoWidth;
                const vidH = video.videoHeight;
                const scaleX = vidW / cssW;
                const scaleY = vidH / cssH;

                const sx = Math.round(rect.left * scaleX);
                const sy = Math.round(rect.top * scaleY);
                const sw = Math.max(1, Math.round(rect.width * scaleX));
                const sh = Math.max(1, Math.round(rect.height * scaleY));

                const canvas = document.createElement('canvas');
                canvas.width = sw;
                canvas.height = sh;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);

                return canvas.toDataURL('image/png');
            } finally {
                stream.getTracks().forEach(t => t.stop());
            }
        }

        // ── 화면 전송 버튼 설정 ──
        (function setupScreenshotSender() {
            const btn = document.getElementById('sendScreenshot');
            if (!btn) return;
            btn.addEventListener('click', async () => {
                try {
                    if (!getPwd()) {
                        showGate('❌ 인증 필요: 먼저 로그인하세요.');
                        return;
                    }
                    btn.disabled = true;
                    const prev = btn.textContent;
                    btn.textContent = '전송 준비중...';

                    const targetEl = findReservationCard();
                    if (!targetEl) throw new Error('캡쳐 대상(현재 예약 현황 카드)을 찾지 못했습니다. id="reservationStatusCard"를 추가해 주세요.');

                    const dataUrl = await captureCardViaScreenShare(targetEl);

                    btn.textContent = '업로드중...';
                    const r = await fetch('/api/screenshot', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...authHeaders() },
                        body: JSON.stringify({ image: dataUrl })
                    });
                    const j = await r.json().catch(() => ({}));
                    if (!r.ok || !j?.ok) throw new Error(j?.error || '업로드 실패');

                    btn.textContent = '✅ 전송 완료';
                    setTimeout(() => { btn.textContent = prev; btn.disabled = false; }, 1200);
                } catch (e) {
                    alert('화면 전송 실패: ' + (e?.message || e));
                    btn.disabled = false;
                    btn.textContent = '🖼️ 화면 전송';
                }
            });
        })();


        // ── 헤더 모달 제어 ──
        function openDialogById(id) {
            if (!id) return;
            const dialog = $(id);
            if (!dialog) return;
            if (typeof dialog.showModal === 'function') {
                dialog.showModal();
            } else {
                dialog.setAttribute('open', '');
            }
        }

        function closeDialog(dialog) {
            if (!dialog) return;
            if (typeof dialog.close === 'function') {
                dialog.close();
            } else {
                dialog.removeAttribute('open');
            }
        }

        document.querySelectorAll('[data-open-modal]').forEach(btn => {
            const target = btn.getAttribute('data-open-modal');
            btn.addEventListener('click', () => {
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                openDialogById(target);
            });
        });

        document.querySelectorAll('[data-close-modal]').forEach(btn => {
            btn.addEventListener('click', () => closeDialog(btn.closest('dialog')));
        });


        document.querySelectorAll('[data-nav-target]').forEach(btn => {
            btn.addEventListener('click', () => {
                const target = btn.getAttribute('data-nav-target') || 'home';
                if (!getPwd()) {
                    showGate('❌ 인증 필요: 먼저 로그인하세요.');
                    return;
                }
                activateView(target);
            });
        });


        async function jsonOrThrow(r) {
            if (!r.ok) {
                if (r.status === 401) { clearPwd(); showGate('❌ 인증 실패. 비밀번호를 다시 입력하세요.'); }
                const t = await r.text().catch(() => '');
                throw new Error(`HTTP ${r.status} ${r.statusText} | ${t.slice(0, 200)}`);
            }
            return r.json();
        }

        function showApp(view = 'home') {
            gate.classList.add('hidden');
            app.classList.remove('hidden');
            activateView(view);
        }

        function showGate(msg = '') {
            app.classList.add('hidden');
            gate.classList.remove('hidden');
            gateMsg.textContent = msg;
            activeView = 'home';
            statusViewInitialized = false;
            timersLoadedOnce = false;
            timerData = [];
            timerIndex = new Map();
            stopTimerTicker();
            if (headerActions) {
                headerActions.classList.add('hidden');
            }
            Object.values(viewSections).forEach(el => el && el.classList.add('hidden'));
            if (timerList) {
                timerList.innerHTML = '<div class="timer-empty">타이머를 추가하면 이곳에 표시됩니다.</div>';
            }
        }

        function showMsg(el, msg, type = '') {
            el.textContent = msg;
            el.classList.remove('hidden', 'success', 'error');
            if (type) el.classList.add(type);
        }

        const statusBox = $('statusBox');
        const mBox = $('mBox');

        function fmtTime(t) {
            if (!t) return '--:--';
            const h = String(t.hour ?? '').padStart(2, '0');
            const m = String(t.minute ?? '').padStart(2, '0');
            return `${h}:${m}`;
        }

        function gearBtn(id) {
            return `<button class="gear" data-gear="${id}" title="출발시간 수정">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 1v6m0 6v6M1 12h6m6 0h6"/>
                    <path d="m4.93 4.93 4.24 4.24m5.66 5.66 4.24 4.24M4.93 19.07l4.24-4.24m5.66-5.66 4.24-4.24"/>
                </svg>
            </button>`;
        }

        // Legacy helper retained to prevent runtime errors in cached scripts expecting renderSlot.
        function renderSlot(label, value) {
            const slotLabel = escapeHtml(label ?? '');
            const rawValue = typeof value === 'string' ? value.trim() : '';
            const empty = !rawValue;
            const slotValue = escapeHtml(empty ? '구인중' : rawValue);
            return `<div class="slot">` +
                `<span class="slot-label">${slotLabel}</span>` +
                `<span class="slot-value ${empty ? 'empty' : ''}">${slotValue}</span>` +
            `</div>`;
        }

        const slotOrder = [
            { key: 'first', heading: '1순' },
            { key: 'second', heading: '2순' },
            { key: 'third', heading: '3순' },
            { key: 'skillbook1', heading: '스킬북1' },
            { key: 'skillbook2', heading: '스킬북2' }
        ];

        const rowOrder = [
            { key: 'nickname', label: '닉네임' },
            { key: 'incentive', label: '인센' },
            { key: 'deposit', label: '예약금' },
            { key: 'loot', label: '득 여부' },
            { key: 'exchange', label: '교환' },
            { key: 'party', label: '파티' }
        ];

        function renderReservationCell(rowKey, column) {
            const detail = column.detail || {};
            const hasReservation = !!detail.hasReservation;
            const slotId = column.slotId;

            if (rowKey === 'nickname') {
                if (!hasReservation) {
                    const bookName = detail.skillbookName ? `<span class="cell-sub">${escapeHtml(detail.skillbookName)}</span>` : '';
                    return `<div class="cell-stack"><span class="cell-empty">구인중</span>${bookName}</div>`;
                }
                const name = `<span class="cell-value">${escapeHtml(detail.nickname)}</span>`;
                const bookName = detail.skillbookName ? `<span class="cell-sub">${escapeHtml(detail.skillbookName)}</span>` : '';
                return `<div class="cell-stack">${name}${bookName}</div>`;
            }

            if (rowKey === 'incentive') {
                if (!hasReservation || !detail.incentive) {
                    return '<span class="cell-empty">-</span>';
                }
                return `<span class="cell-value">${escapeHtml(detail.incentive)}</span>`;
            }

            if (rowKey === 'deposit') {
                return formatDepositValue(detail);
            }

            if (rowKey === 'loot') {
                const disabled = !hasReservation;
                const checked = !disabled && lootState[slotId];
                const classes = ['loot-mark'];
                if (disabled) classes.push('is-disabled');
                return `<label class="${classes.join(' ')}">
                    <input type="checkbox" ${disabled ? 'disabled' : ''} data-loot-slot="${escapeAttr(slotId)}" data-slot-active="${disabled ? '0' : '1'}" ${checked ? 'checked' : ''} />
                    <span>획득</span>
                </label>`;
            }

            if (rowKey === 'exchange' || rowKey === 'party') {
                if (!hasReservation) {
                    return '<span class="cell-empty">-</span>';
                }
                const prefix = rowKey === 'exchange' ? '/교환 ' : '/파티초대 ';
                const label = rowKey === 'exchange' ? '교환' : '파티';
                const text = `${prefix}${detail.nickname}`;
                return `<button type="button" class="copy-btn" data-copy-text="${escapeAttr(text)}" data-copy-label="${label}" data-slot="${escapeAttr(slotId)}">${label}</button>`;
            }

            return '<span class="cell-empty">-</span>';
        }

        function renderTurnSection(label, gearKey, time, detail = {}, extraClass = '', turnKey = '', skillbookDetail = {}) {
            const slots = slotOrder.map(col => {
                const slotId = col.key.startsWith('skillbook') ? col.key : `${turnKey}-${col.key}`;
                const baseDetail = col.key.startsWith('skillbook') ? skillbookDetail[col.key] : detail[col.key];
                return {
                    ...col,
                    slotId,
                    detail: baseDetail || {}
                };
            });

            const headerRow = rowOrder.map(row => `<th scope="col">${row.label}</th>`).join('');
            const bodyRows = slots.map(slot => {
                const cells = rowOrder.map(row => `<td>${renderReservationCell(row.key, slot)}</td>`).join('');
                return `<tr><th scope="row">${slot.heading}</th>${cells}</tr>`;
            }).join('');

            return `<section class="turn-section ${extraClass}">
                <div class="turn-header">
                    <div class="turn-title">
                        <span>${label}</span>
                        <span class="turn-time">${fmtTime(time)}</span>
                    </div>
                    ${gearBtn(gearKey)}
                </div>
                <div class="table-wrapper">
                    <table class="reservation-table">
                        <thead>
                            <tr>
                                <th scope="col">구분</th>
                                ${headerRow}
                            </tr>
                        </thead>
                        <tbody>
                            ${bodyRows}
                        </tbody>
                    </table>
                </div>
            </section>`;
        }

        async function copyTextToClipboard(text) {
            if (!text) return false;
            try {
                if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.opacity = '0';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    temp.remove();
                }
                return true;
            } catch (err) {
                console.error('clipboard error', err);
                return false;
            }
        }

        function attachCopyHandlers(root) {
            root.querySelectorAll('button.copy-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    if (btn.disabled) return;
                    const text = btn.getAttribute('data-copy-text');
                    const label = btn.getAttribute('data-copy-label') || btn.textContent;
                    const ok = await copyTextToClipboard(text);
                    if (!ok) return;
                    btn.textContent = '복사됨!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = label;
                        btn.classList.remove('copied');
                    }, 1200);
                });
            });
        }

        function applyLootState(root) {
            const activeSlots = new Set();
            root.querySelectorAll('[data-loot-slot]').forEach(input => {
                const slot = input.getAttribute('data-loot-slot');
                if (!slot) return;
                const isActive = input.getAttribute('data-slot-active') === '1' && !input.disabled;
                if (!isActive) {
                    input.checked = false;
                    if (lootState[slot]) delete lootState[slot];
                    return;
                }
                activeSlots.add(slot);
                input.checked = !!lootState[slot];
            });
            Object.keys(lootState).forEach(key => {
                if (!activeSlots.has(key)) {
                    delete lootState[key];
                }
            });
            saveLootState();
        }

        function bindLootCheckboxes(root) {
            root.querySelectorAll('[data-loot-slot]').forEach(input => {
                input.addEventListener('change', () => {
                    const slot = input.getAttribute('data-loot-slot');
                    if (!slot) return;
                    if (input.checked) {
                        lootState[slot] = true;
                    } else {
                        delete lootState[slot];
                    }
                    saveLootState();
                    root.querySelectorAll(`[data-loot-slot="${slot}"]`).forEach(other => {
                        if (other === input) return;
                        if (other.disabled) return;
                        other.checked = input.checked;
                    });
                });
            });
        }

        function renderExtraCard(title, data, extraClass = '') {
            const isObject = data && typeof data === 'object';
            const reservation = isObject ? data?.reservation : data;
            const subtitle = isObject ? data?.name : '';
            const str = reservation == null ? '' : String(reservation).trim();
            const isEmpty = !str;
            const display = isEmpty ? '구인중' : str;
            const name = subtitle ? `<div class="cell-sub">${escapeHtml(subtitle)}</div>` : '';
            return `<div class="extra-card ${extraClass}">
                <div class="extra-title">${title}</div>
                <div class="extra-content ${isEmpty ? 'empty' : ''}">${display}</div>
                ${name}
            </div>`;
        }

        function renderStatus(j) {
            const t1 = j?.departureTimes?.turn1;
            const t2 = j?.departureTimes?.turn2;
            const turnRowHtml = `
                <div class="turn-row">
                    ${renderTurnSection('🔸 1트', 't1', t1, j?.turn1Details, '', 't1', j?.skillbookDetails)}
                    ${renderTurnSection('🔹 2트', 't2', t2, j?.turn2Details, 'turn2', 't2', j?.skillbookDetails)}
                </div>`;

            const sb1 = j?.skillbook1 ?? {};
            const sb2 = j?.skillbook2 ?? {};
            const enre = Array.isArray(j?.enreEat) ? j.enreEat : [];

            const extraHtml = `
                <div class="extra-grid">
                    ${renderExtraCard('📚 스킬북1', sb1)}
                    ${renderExtraCard('📚 스킬북2', sb2, 'skill2')}
                    ${renderExtraCard('👼 엔레먹자', enre.length ? enre.join(', ') : '', 'enre')}
                </div>`;

            statusBox.innerHTML = turnRowHtml + extraHtml;
            attachCopyHandlers(statusBox);
            applyLootState(statusBox);
            bindLootCheckboxes(statusBox);

            $('p1').value = j?.prices?.firstSecond ?? '';
            $('p2').value = j?.prices?.third ?? '';
            $('p3').value = j?.prices?.skillbook1 ?? '';
            $('p4').value = j?.prices?.skillbook2 ?? '';

            statusBox.querySelectorAll('[data-gear]').forEach(btn => {
                btn.onclick = () => openTimeModal(btn.getAttribute('data-gear'), j);
            });

            const members = Array.isArray(j?.guildMembers) ? j.guildMembers : [];
            if (!members.length) {
                mBox.innerHTML = '<div class="status-msg">등록된 공대원이 없습니다</div>';
            } else {
                mBox.innerHTML = members.map(m => `
                    <div class="member-item">
                        <div class="member-info">
                            <span class="member-name">${m.nickname}</span>
                            <span class="member-job">${m.job}</span>
                        </div>
                    </div>`).join('');
            }
        }

        async function loadStatus() {
            statusViewInitialized = true;
            statusBox.innerHTML = '<div class="status-msg">불러오는 중...</div>';
            try {
                const r = await fetch('/api/status', { headers: authHeaders(), credentials: 'same-origin' });
                const j = await jsonOrThrow(r);
                renderStatus(j);
            } catch (e) {
                statusBox.innerHTML = `<div class="status-msg error">에러: ${e.message}</div>`;
            }
        }

        $('savePrices').onclick = async () => {
            const msg = $('priceMsg');
            showMsg(msg, '저장 중...');
            try {
                const body = {
                    firstSecond: $('p1').value,
                    third: $('p2').value,
                    skillbook1: $('p3').value,
                    skillbook2: $('p4').value
                };
                const r = await fetch('/api/prices', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...authHeaders() },
                    body: JSON.stringify(body),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                showMsg(msg, '✅ 시세가 저장되었습니다', 'success');
            } catch (e) {
                showMsg(msg, '❌ ' + e.message, 'error');
            }
        };

        $('resetSome').onclick = async () => {
            const msg = $('resetMsg');
            showMsg(msg, '진행 중...');
            try {
                const items = Array.from($('resetSel').selectedOptions).map(o => o.value);
                const r = await fetch('/api/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...authHeaders() },
                    body: JSON.stringify({ items }),
                    credentials: 'same-origin'
                });
                const j = await jsonOrThrow(r);
                showMsg(msg, '✅ 초기화됨: ' + (j.resetItems?.join(', ') || '-'), 'success');
            } catch (e) {
                showMsg(msg, '❌ ' + e.message, 'error');
            }
        };

        $('resetAll').onclick = async () => {
            if (!confirm('정말 모든 예약을 초기화할까요?')) return;
            const msg = $('resetMsg');
            showMsg(msg, '진행 중...');
            try {
                const r = await fetch('/api/reset-all', {
                    method: 'POST',
                    headers: authHeaders(),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                showMsg(msg, '✅ 모든 예약이 초기화되었습니다', 'success');
            } catch (e) {
                showMsg(msg, '❌ ' + e.message, 'error');
            }
        };

        $('mAdd').onclick = async () => {
            const nickname = prompt('공대원 닉네임:');
            if (!nickname) return;
            const job = prompt('직업:');
            if (!job) return;
            const msg = $('mMsg');
            showMsg(msg, '추가 중...');
            try {
                const r = await fetch('/api/members', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...authHeaders() },
                    body: JSON.stringify({ nickname, job }),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                showMsg(msg, '✅ 공대원이 추가되었습니다', 'success');
                loadStatus();
            } catch (e) {
                showMsg(msg, '❌ ' + e.message, 'error');
            }
        };

        $('mDel').onclick = async () => {
            const nickname = prompt('삭제할 닉네임:');
            if (!nickname) return;
            const msg = $('mMsg');
            showMsg(msg, '삭제 중...');
            try {
                const r = await fetch('/api/members', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json', ...authHeaders() },
                    body: JSON.stringify({ nickname }),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                showMsg(msg, '✅ 공대원이 삭제되었습니다', 'success');
                loadStatus();
            } catch (e) {
                showMsg(msg, '❌ ' + e.message, 'error');
            }
        };

        $('mReload').onclick = loadStatus;

        const timeDialog = $('timeDialog');
        const th = $('th');
        const tm = $('tm');
        const timeTitle = $('timeTitle');
        let editingTurn = null;

        function openTimeModal(turnKey, snapshot) {
            editingTurn = turnKey;
            const target = (turnKey === 't1') ? snapshot?.departureTimes?.turn1 : snapshot?.departureTimes?.turn2;
            timeTitle.textContent = (turnKey === 't1') ? '⏰ 출발시간 변경 - 1트' : '⏰ 출발시간 변경 - 2트';
            th.value = target?.hour ?? '';
            tm.value = target?.minute ?? '';
            if (typeof timeDialog.showModal === 'function') {
                timeDialog.showModal();
            } else {
                const h = prompt(timeTitle.textContent + ' | 시(0-23):', th.value ?? '');
                if (h == null) return;
                const m = prompt(timeTitle.textContent + ' | 분(0-59):', tm.value ?? '');
                if (m == null) return;
                th.value = h;
                tm.value = m;
                saveTime();
            }
        }

        $('timeCancel').onclick = () => timeDialog.close();
        $('timeSave').onclick = saveTime;

        async function saveTime() {
            if (!editingTurn) return;
            const h = parseInt(th.value, 10);
            const m = parseInt(tm.value, 10);
            const body = (editingTurn === 't1')
                ? { turn1Hour: h, turn1Minute: m }
                : { turn2Hour: h, turn2Minute: m };
            try {
                const r = await fetch('/api/times', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...authHeaders() },
                    body: JSON.stringify(body),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                timeDialog.close();
                loadStatus();
            } catch (e) {
                alert('저장 실패: ' + e.message);
            } finally {
                editingTurn = null;
            }
        }

        $('loginBtn').onclick = async () => {
            const v = $('pwd').value?.trim();
            if (!v) {
                gateMsg.textContent = '비밀번호를 입력하세요.';
                return;
            }
            setPwd(v);
            gateMsg.textContent = '확인 중...';
            try {
                const r = await fetch('/api/status', {
                    headers: authHeaders(),
                    credentials: 'same-origin'
                });
                await jsonOrThrow(r);
                statusViewInitialized = true;
                showApp('home');
                loadStatus();
                connectSocket();
            } catch {
                gateMsg.textContent = '❌ 접속 실패';
                clearPwd();
            }
        };

        $('pwd').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') $('loginBtn').click();
        });

        let socket;
        function connectSocket() {
            if (socket) {
                try { socket.disconnect(); } catch { }
            }
            socket = io('/', {
                path: '/socket.io',
                auth: { pwd: getPwd() }
            });
            socket.on('status', (data) => {
                const j = data?.status;
                if (j) renderStatus(j);
            });
            socket.on('timers', (data) => {
                const snapshot = data?.snapshot || data;
                if (snapshot) setTimerSnapshot(snapshot);
            });
            socket.on('connect_error', (err) => {
                if (String(err?.message || '').includes('unauthorized')) {
                    clearPwd();
                    showGate('❌ 인증 실패. 비밀번호를 다시 입력하세요.');
                }
                setTimeout(connectSocket, 1500);
            });
            socket.on('disconnect', () => setTimeout(connectSocket, 1500));
        }

        if (getPwd()) {
            statusViewInitialized = true;
            showApp('home');
            loadStatus();
            connectSocket();
        } else {
            showGate();
        }
    </script>
</body>

</html>